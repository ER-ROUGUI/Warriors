import cv2

def main():
    # Initialize video capture on the first video device
    cap = cv2.VideoCapture(0)

    if not cap.isOpened():
        print("Error: Camera is not connected or cannot be accessed.")
        return

    try:
        while True:
            # Capture frame-by-frame
            ret, frame = cap.read()

            if not ret:
                print("Error: Can't receive frame (stream end?). Exiting...")
                break

            # Display the resulting frame
            cv2.imshow('Video Capture', frame)

            # Press 'q' to exit the loop
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
    finally:
        # When everything done, release the capture
        cap.release()
        cv2.destroyAllWindows()

if __name__ == '__main__':
    main()











import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import yaml

class RobotSpecPublisher(Node):
    def __init__(self):
        super().__init__('robot_spec_publisher')
        self.publisher_ = self.create_publisher(String, 'robot_specifications', 10)
        self.timer = self.create_timer(5.0, self.publish_robot_specs)

    def publish_robot_specs(self):
        # Load robot specifications from a YAML file
        with open('/path/to/your/config.yaml', 'r') as file:
            robot_specs = yaml.safe_load(file)
            specs_str = yaml.dump(robot_specs)
            self.publisher_.publish(String(data=specs_str))
            self.get_logger().info(f'Published robot specifications: {specs_str}')

def main(args=None):
    rclpy.init(args=args)
    robot_spec_publisher = RobotSpecPublisher()
    rclpy.spin(robot_spec_publisher)
    robot_spec_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()




import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from geometry_msgs.msg import PoseStamped
import yaml

class TaskManager(Node):
    def __init__(self):
        super().__init__('task_manager')
        self.robot_specs = {}
        self.robot_navigators = {}  # Stores navigator instances or command publishers for each robot

        self.specs_subscription = self.create_subscription(
            String,
            'robot_specifications',
            self.handle_robot_specs,
            10)

    def handle_robot_specs(self, msg):
        specs = yaml.safe_load(msg.data)
        robot_name = specs["robot_name"]
        self.robot_specs[robot_name] = specs
        self.get_logger().info(f'Received specs from {robot_name}: {specs}')

        # Initialize navigator for the robot if not already done
        if robot_name not in self.robot_navigators:
            self.robot_navigators[robot_name] = self.create_robot_navigator(robot_name)
            self.get_logger().info(f"Navigator initialized for {robot_name}")

        self.evaluate_task()

    def create_robot_navigator(self, robot_name):
        # This function creates a publisher for the specific robot
        navigator_publisher = self.create_publisher(
            PoseStamped,
            f'/{robot_name}/goal_pose',
            10)
        return navigator_publisher

    def handle_robot_pose(self, pose_msg, robot_name):
        # Update robot's position in the stored specifications
        if robot_name in self.robot_specs:
            self.robot_specs[robot_name]['current_location'] = [
                pose_msg.pose.position.x,
                pose_msg.pose.position.y
            ]
            self.get_logger().info(f"Updated position for {robot_name}: {self.robot_specs[robot_name]['current_location']}")

    def evaluate_task(self):
        # Example task processing logic here
        # Decide which robot to assign the task to based on criteria
        chosen_robot_name = "robot1"  # Placeholder for chosen robot based on your criteria
        self.assign_task(chosen_robot_name, [2.0, 3.0])

    def assign_task(self, robot_name, task_location):
        if robot_name in self.robot_navigators:
            goal_pose = PoseStamped()
            goal_pose.header.frame_id = 'map'
            goal_pose.header.stamp = self.get_clock().now().to_msg()
            goal_pose.pose.position.x = task_location[0]
            goal_pose.pose.position.y = task_location[1]
            goal_pose.pose.orientation.w = 1.0  # Assuming the robot faces the task directly

            self.get_logger().info(
                f"Assigning task to {robot_name}. Sending to location {task_location}"
            )
            # Publish the goal pose to the specific robot's navigator
            self.robot_navigators[robot_name].publish(goal_pose)

def main(args=None):
    rclpy.init(args=args)
    task_manager = TaskManager()
    rclpy.spin(task_manager)
    task_manager.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()














cmake_minimum_required(VERSION 3.8)
project(navigation_turtlebot)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra
# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(nav_msgs REQUIRED)
# New Eidtions
find_package(ament_cmake_python REQUIRED)
find_package(rclpy REQUIRED)
#

# add_executable(pub_occupancy_grid src/pub_occupancy_grid.cpp)
# ament_target_dependencies(pub_occupancy_grid rclcpp nav_msgs)

# install(TARGETS
#   pub_occupancy_grid
#   DESTINATION lib/${PROJECT_NAME})

install( DIRECTORY launch/
         DESTINATION share/${PROJECT_NAME}/launch)
install( DIRECTORY config/
         DESTINATION share/${PROJECT_NAME}/config)


ament_python_install_package(${PROJECT_NAME})
# Python Executables into Lib

install(PROGRAMS scripts/single_goal_nav.py
        DESTINATION lib/${PROJECT_NAME})

        install(PROGRAMS scripts/multi_waypoints.py
        DESTINATION lib/${
        install(PROGRAMS scripts/robot_bringup.py
        DESTINATION lib/${PROJECT_NAME})

ament_package()
