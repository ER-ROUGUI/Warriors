HERE I WANT TO ADD INFOR ON IMAGE LIKE WHEN I DETECT THE OBJECT CLASS='OBJECT' I WANT TO WRITE SOMTHING IN TOP OF THE RECTONGLE EVEN IF THE RECTONGLE SHOWS AND HIDE SO THE WRITTING WILL BE STABLE SO THE USER WILL SEE IT
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import Image
from geometry_msgs.msg import PointStamped
import cv2
import numpy as np
from cv_bridge import CvBridge
from ultralytics import YOLO
import open3d as o3d 
from ament_index_python.packages import get_package_share_directory
import pyrealsense2 as rs
import os


# smart_robots_dir = get_package_share_directory("smart_robots_controller")
# model_file = os.path.join(smart_robots_dir, "config", "yolov8n.pt")
model_file = "/app/augmented-robots/server/nux_ws/src/smart_robots_controller/config/yolov8n.pt"

model = YOLO(model_file)
class ImageSubscriber(Node):

    def __init__(self):
        super().__init__('image_subscriber_yolo')
        self.image_sub = self.create_subscription(Image, '/camera/image_raw/compressed', self.image_callback, 10)
        self.depth_sub = self.create_subscription(PointStamped, 'image/zDepth', self.zDepth_callback, 10)

        self.label_pub = self.create_publisher(String , '/detected_status' , 10)
        self.last_detected = False


        self.bridge = CvBridge()

        timer_period = 0.5

        self.center_pub = self.create_publisher(PointStamped , '/image/center_coordinates' , 10)
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0
        self.center_coordinates = []


    

    def image_callback(self, msg):
        # global center_coordinates


        decoded_data = np.frombuffer(msg.data, dtype=np.uint8)
        decoded_image = cv2.imdecode(decoded_data, cv2.IMREAD_COLOR) 

        rbg_image = cv2.cvtColor(decoded_image , cv2.COLOR_BGR2RGB)

        results = model(rbg_image)
        results = model.predict(source=rbg_image, show=False, stream=True, verbose=False) 
        person_detected = False

        for r in results:
            boxes = r.boxes
            for box in boxes:
            # bounding box
                #print(box.xyxy[0])
                x1, y1, x2, y2 = box.xyxy[0]
                confidence =box.conf[0]
                cls = int(box.cls[0])

                if model.names[cls] == "person" and confidence > 0.5 : # we can use door or window instead person !!!

                    person_detected = True
                    
                    cv2.rectangle(decoded_image , (int(x1),int(y1)) , (int(x2) , int(y2)) , (0,255,0) , 2)


                    (x_center,y_center) = (x2 + x1)/2, (y2+y1)/2 
                    center_coordinates = (int(x_center),int(y_center))

                    try:
                        
                        # zDepth = None  #depth_frame.get_distance(int(x_center),int(y_center))
                        print("Nothing just  ....." )

                    except (AttributeError , NameError):
                        print("Depth unavailable")

                    
                    # print(zDepth)

                    frame_center = (rbg_image.shape[1]//2 ,rbg_image.shape[0]//2)
                    error_x = center_coordinates[0] - frame_center[0]
                    error_y = center_coordinates[1] - frame_center[1]

                    self.center_coordinates.append(  (int(x_center) , int(y_center) ))

                    # print(f"Error: x ={error_x} , y={error_y}")

                    # center_msg = PointStamped()
                    # center_msg.header.stamp = self.get_clock().now().to_msg()
                    # center_msg.point.x = x_center
                    # center_msg.point.y = y_center
                    # self.center_pub.publish(center_msg)
                    # self.get_logger().info(f"Center coordinates : ({x_center} , {y_center})")
                    
                    if center_coordinates is not None :
            
                        cv2.circle(decoded_image, center_coordinates, 5, (0,0,255), 5)


        if person_detected:
            if not self.last_detected:
                self.label_pub.publish(String(data="person has been detected")) 
                self.last_detected = True

        else:

            if self.last_detected:
                self.label_pub.publish(String(data="No detection yet !!"))      
                self.last_detected = False
               

        cv2.imshow('RealSense Image subscriber', decoded_image)
        cv2.waitKey(1)

    def timer_callback(self):


        if len(self.center_coordinates)>0 :

            x_center , y_center = self.center_coordinates[-1]

            msg = PointStamped()
            msg.header.stamp = self. get_clock().now().to_msg()
            msg.point.x = float(x_center)
            msg.point.y = float(y_center)

            self.center_pub.publish(msg)
            self.get_logger().info(f"Publishing center Coordinates: {msg.point.x} ,{msg.point.y}")
            self.i += 1
        else:
            self.get_logger().info('No center Coordinates:')

    def zDepth_callback(self ,msg):

        msg = PointStamped()
        msg.header.stamp = self.get_clock().now().to_msg()
        # msg.point.z = float(x_center)
        # x_center  =center_msg.point.x
        # y_center =center_msg.point.y
        zDepth  = msg.point.z

        self.get_logger().info(f"Publishing zDepth value: {zDepth}")
        

 



def main():
    rclpy.init()
    node = ImageSubscriber()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
