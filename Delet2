import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from geometry_msgs.msg import PointStamped
from cv_bridge import CvBridge
import cv2
import numpy as np

class ImagePublisher(Node):

    def __init__(self):
        super().__init__('image_publisher')
        self.publisher_ = self.create_publisher(Image, '/camera/image_raw/compressed', 10)
        self.bridge = CvBridge()

        # Initialize video capture from the camera's video stream
        self.cap = cv2.VideoCapture('rtsp://your_camera_ip/stream')  # Adjust the URL to your camera's specifications

        self.timer_period = 0.1  # Adjust as needed
        self.timer = self.create_timer(self.timer_period, self.timer_callback)

    def timer_callback(self):
        ret, frame = self.cap.read()  # Read a frame from the camera
        if not ret:
            return

        _, compressed_image_data = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 20])
        compressed_image_data = compressed_image_data.tobytes()
        
        msg = Image()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.data = compressed_image_data
        msg.encoding = 'jpeg'
        self.publisher_.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    image_publisher = ImagePublisher()
    rclpy.spin(image_publisher)
    rclpy.shutdown()

if __name__ == '__main__':
    main()








this code for publishing images from realsense camera use the same code but for a camera MINI camera model Q18 wifi

import rclpy 
from rclpy.node import Node 
from sensor_msgs.msg import Image 
from geometry_msgs.msg import PointStamped
from cv_bridge import CvBridge 
import cv2 
import pyrealsense2 as rs
import numpy as np
 
class ImagePublisher(Node):
 
  def __init__(self):
 
  
    super().__init__('image_publisher')

    self.publisher_ = self.create_publisher(Image, '/camera/image_raw/compressed', 10) 
    self.bridge = CvBridge()
    self.center_sub = self.create_subscription(PointStamped , '/image/center_coordinates' , self.center_callback ,10)
    self.depth_pub = self.create_publisher(PointStamped , '/image/zDepth' , 10)

    self.pipeline =  rs.pipeline()
    config = rs.config()
    config.enable_stream(rs.stream.depth , 640 ,480 , rs.format.z16 , 30)
    config.enable_stream(rs.stream.color , 640 ,480 , rs.format.bgr8 , 30) # FPS = 30 

    self.pipeline.start(config)

  
    self.timer_period = 0.1  
    self.timer = self.create_timer(self.timer_period , self.timer_callback)
    self.x_center = None
    self.y_center = None 
    self.center_updated = False

  def timer_callback(self):
    frames = self.pipeline.wait_for_frames()  
    color_frame = frames.get_color_frame()
    depth_frame = frames.get_depth_frame()
    
    if not depth_frame or not color_frame:
      return

    color_image = np.asanyarray(color_frame.get_data()) 
    _ , compressed_image_data = cv2.imencode('.jpg' , color_image , [cv2.IMWRITE_JPEG_QUALITY , 20])
    compressed_image_data  = compressed_image_data.tobytes()
    msg = Image()
    msg.header.stamp = self.get_clock().now().to_msg()
    msg.data = compressed_image_data 
    msg.encoding = 'jpeg'
    self.publisher_ .publish(msg) 
#      self.timer_callback(self.x_center , self.y_center)

    if self.x_center is not None and self.y_center is not None:
      zDepth = depth_frame.get_distance(int(self.x_center),int(self.y_center))
      depth_msg = PointStamped()
      depth_msg.header.stamp = self.get_clock().now().to_msg()
      depth_msg.point.x = self.x_center
      depth_msg.point.y = self.y_center
      depth_msg.point.z = zDepth
      self.depth_pub.publish(depth_msg)
      self.get_logger().info(f"Depth is  : {zDepth}")
      self.center_updated = False
  
  def center_callback(self ,msg):
    
    self.x_center = msg.point.x
    self.y_center = msg.point.y
#    zDepth = depth_frame.get_distance(int(self.x_center),int(self.y_center))
#    self.center_callback(self.x_center ,self.y_center)
#    self.get_logger().info(f"Depth is  : {zDepth})")
#    self.get_logger().info('I heard: "%s"' % msg.zDepth)
    self.center_updated = True
#                  
    
   
def main(args=None):

  rclpy.init(args=args)
  

  image_publisher = ImagePublisher()

  rclpy.spin(image_publisher)
  
  rclpy.shutdown()
  
if __name__ == '__main__':
  main()
