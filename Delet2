import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import paho.mqtt.client as mqtt

class ROS2ToMQTTBridge(Node):
    def __init__(self):
        super().__init__('ros2_to_mqtt_bridge')
        self.subscription = self.create_subscription(String, 'availability', self.ros2_callback, 10)
        self.mqtt_client = mqtt.Client()
        self.mqtt_client.username_pw_set("ros2", "niceiam21!")
        self.mqtt_client.connect("localhost", 1883, 60)  # Adjust MQTT broker address and port as needed

    def ros2_callback(self, msg):
        self.mqtt_client.publish('availability', msg.data)
        self.get_logger().info(f'Published to MQTT: {msg.data}')

def main(args=None):
    rclpy.init(args=args)
    bridge_node = ROS2ToMQTTBridge()
    rclpy.spin(bridge_node)
    bridge_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()


import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import paho.mqtt.client as mqtt
import json

class ROS2ToMQTTBridge(Node):
    def __init__(self):
        super().__init__('ros2_to_mqtt_bridge')
        self.subscription = self.create_subscription(String, 'availability', self.ros2_callback, 10)
        self.mqtt_client = mqtt.Client()
        self.mqtt_client.username_pw_set("ros2", "niceiam21!")
        self.mqtt_client.connect("localhost", 1883, 60)  # Adjust MQTT broker address and port as needed

    def ros2_callback(self, msg):
        try:
            status = json.loads(msg.data)
            self.mqtt_client.publish('availability', json.dumps(status))
            self.get_logger().info(f'Published to MQTT: {status}')
        except json.JSONDecodeError as e:
            self.get_logger().error(f'Error decoding JSON: {e}')

def main(args=None):
    rclpy.init(args=args)
    bridge_node = ROS2ToMQTTBridge()
    rclpy.spin(bridge_node)
    bridge_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()





import paho.mqtt.client as mqtt
from datetime import datetime
import yaml
import json
import os

"""
this code will subscriber to the mqtt topic "suspicious" sent by IOT Manager then chose one of the robot condidat to do task 
and send mqtt trigger to smart robot controller Bloc
"""
robot_statuses = {}
# Load configuration from YAML file ###################################
def load_config(filename):
    base_path = os.path.dirname(__file__)
    config_path = os.path.join(base_path, 'config', filename)
    with open(config_path, 'r') as file:
        return yaml.safe_load(file)
    
def load_json(filename):
    base_path = os.path.dirname(__file__)
    config_path = os.path.join(base_path, 'config', filename)
    with open(config_path, 'r') as file:
        return json.load(file)

config = load_config('mqtt_config.yaml')
config_robots = load_json('robot_config.json')
mqtt_settings = config['mqtt_settings']

#########################################################################
def on_connect(client, userdata, flags, rc):
    if rc ==0 :

        print("Connected to IOT Manager")
        client.subscribe(mqtt_settings['mqtt_topic_pub'])
        print("subscriber to topic from IOT Manager")

    else:
        print("failed to connect")

        

def on_message(client, userdata, msg):
    message = msg.payload.decode("utf-8")
    print("received msg from Iot manager")

    try:
        data = json.loads(message)
        if data == "suspicious" :
            client.publish(mqtt_settings['mqtt_topic_controller'], "navigate")
            print(f"Publeshed msg to Smart robots controller")

        print(f"Received message from topic '{msg.topic}': {message}")

    except json.JSONDecodeError as e :
        print(f"Error decoding Json: {e}")

################################################################################

# def on_robot_status(client, userdata, message): # I can just use a node to publish statue

#     "here i need subscriber whitch will returne the availabilitÃ© of the two robots as "
#     robot_statuses = {"turtelebot": 'available' , "husarion":'unavailable'}


#     pass


# def analyze_task(data, config):
#     current_hour = datetime.now().hour
#     noise_type = data.get('noise_type')
    
#     assigned_robot = None
#     for robot in config['robots']:
#         robot_id = robot['id']
#         if robot_id in robot_statuses:
#             status = robot_statuses[robot_id]
#             if status['availability'] and status['battery_level'] > 20 and status['wifi_quality'] > 50:
#                 if noise_type == 'knock' and 'navigate' in robot['tasks']:
#                     assigned_robot = robot
#                     break
#                 elif noise_type == 'ding' and 'capture_image' in robot['tasks']:
#                     assigned_robot = robot
#                     break
 

#     if noise_type == 'knock':
#         for robot in config['robots']:
#             robot_id = robot['id']
#             if robot_id in robot_statuses:
#                 status = robot_statuses[robot_id]
#                 if status['availability'] == 'somthing' :
#                     break


#     return assigned_robot

def main():

    config = load_config('mqtt_config.yaml')
    mqtt_settings = config['mqtt_settings']
    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_message = on_message
    # Connect to the local broker
    client.username_pw_set("ros2", "niceiam21!")
    client.connect(mqtt_settings['mqtt_local_brocker'], mqtt_settings['mqtt_port'], 60)

    client.loop_forever()

if __name__ == "__main__":
    main()
