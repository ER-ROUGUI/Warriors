import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from nav2_msgs.action import NavigateToGoal

class GoalPublisher(Node):

  def __init__(self):
    super().__init__('goal_publisher')
    self.goal_pub = self.create_publisher(PoseStamped, '/goal_pose', 10)  # Queue size: 10 messages
    self.client = self.create_client(NavigateToGoal, '/navigate_to_goal')
    self.timer = self.create_timer(1.0, self.publish_goal)  # Publish every 1 second

    # Définir trois poses d'objectif
    self.goal_poses = [
      {  # Goal 1 (x=0.2, y=0.0)
        'x': 0.2,
        'y': 0.0,
        'z': 0.0,
        'w': 1.0,
      },
      {  # Goal 2 (x=0.5, y=0.5)
        'x': 0.5,
        'y': 0.5,
        'z': 0.0,
        'w': 1.0,
      },
      {  # Goal 3 (x=-0.2, y=-0.2)
        'x': -0.2,
        'y': -0.2,
        'z': 0.0,
        'w': 1.0,
      },
    ]

    self.goal_index = 0  # Index pour suivre l'objectif actuel
    self.goal_sent = False  # Indicateur si l'objectif actuel a été envoyé

  def publish_goal(self):
    if self.goal_index >= len(self.goal_poses):
      self.get_logger().info('Tous les objectifs ont été publiés. Sortie.')
      self.timer.cancel()  # Arrêter le timer après la publication de tous les objectifs
      return

    if not self.goal_sent:
      goal_pose = PoseStamped()
      goal_pose.header.stamp.sec = 0  # Définir l'horodatage à 0 seconde
      goal_pose.header.frame_id = 'map'  # Définir l'ID de trame sur 'map'

      current_goal = self.goal_poses[self.goal_index]
      goal_pose.pose.position.x = current_goal['x']
      goal_pose.pose.position.y = current_goal['y']
      goal_pose.pose.position.z = current_goal['z']
      goal_pose.pose.orientation.w = current_goal['w']  # Pas de rotation

      self.goal_pub.publish(goal_pose)
      self.get_logger().info(f'Objectif publié {self.goal_index + 1}.')

      self.goal_sent = True

    # Envoyer une requête de navigation vers l'objectif actuel
    goal_request = NavigateToGoal.Request()
    goal_request.goal.pose = goal_pose

    self.client.call_async(goal_request)

    # Définir un timer pour vérifier l'état de la navigation
    self.check_navigation_status_timer = self.create_timer(1.0, self.check_navigation_status)

  def check_navigation_status(self):
    if self.client.is_response_received:
      response = self.client.get_result()
      if response.result.status.code == 1:  # Goal reached
        self.get_logger().info('Objectif atteint.')
        self.goal_sent = False  # Réinitialiser l'indicateur pour envoyer l'objectif suivant
        self.check_navigation_status_timer.cancel()  # Arrêter le timer de vérification

def main():
  rclpy.init()
  goal_publisher = GoalPublisher()
  rclpy.spin(goal_publisher)
  rclpy.shutdown()

if __name__ == '__main__':
  main()
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped

class GoalPosePublisher(Node):

  def __init__(self):
    super().__init__('goal_pose_publisher')
    self.goal_pub = self.create_publisher(PoseStamped, '/goal_pose', 10)  # Queue size: 10 messages
    self.timer = self.create_timer(1.0, self.publish_goal_pose)  # Publish every 1 second (adjust as needed)

    # Define the goal pose
    self.goal_pose = PoseStamped()
    self.goal_pose.header.stamp.sec = 0  # Set timestamp to 0 seconds
    self.goal_pose.header.frame_id = 'map'  # Set frame_id

    self.goal_pose.pose.position.x = 2.3  # X coordinate of the goal (meters)
    self.goal_pose.pose.position.y = 0.0  # Y coordinate of the goal (meters)
    self.goal_pose.pose.position.z = 1.5  # Z coordinate of the goal (meters) (optional, often 0 for 2D)
    self.goal_pose.pose.orientation.w = 0.9  # Quaternion for no rotation (w component)

  def publish_goal_pose(self):
    self.goal_pub.publish(self.goal_pose)
    self.get_logger().info('Published goal pose.')

def main():
  rclpy.init()
  goal_pose_publisher = GoalPosePublisher()
  rclpy.spin(goal_pose_publisher)
  rclpy.shutdown()

if __name__ == '__main__':
  main()
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from nav2_msgs.srv import NavigateToPose
from tf2_ros import TransformBroadcaster, TransformListener

class RelativeGoalPublisher(Node):

  def __init__(self):
    super().__init__('relative_goal_publisher')
    self.goal_pub = self.create_client(NavigateToPose, '/move_base')  # Service for sending navigation goals
    self.tf_buffer = TransformListener(self)
    self.tf_broadcaster = TransformBroadcaster(self)
    self.timer = self.create_timer(1.0, self.get_initial_pose_and_send_goal)  # Timer to trigger actions

    self.initial_pose_received = False  # Flag to indicate if initial pose is received
    self.initial_pose = None  # Placeholder for initial pose

    self.relative_x_offset = 1.0  # Desired X-axis offset (meters)

  def get_initial_pose_and_send_goal(self):
    if self.initial_pose_received:
      return  # Skip if initial pose is already received and sent

    # Get the robot's current pose in the map frame (assuming it's broadcasted)
    try:
      transform = self.tf_buffer.lookup_transform('map', 'base_link', rclpy.time.Time())
      self.initial_pose = transform.transform.translation
      self.initial_pose_received = True
      self.send_relative_goal()
    except (LookupError, rclpy.exceptions.ROSInterruptException) as e:
      self.get_logger().warn(f'Error getting initial pose: {e}')
      self.initial_pose_received = False  # Reset flag on error

  def send_relative_goal(self):
    # ... (rest of the code for sending the relative goal pose remains the same)
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from nav2_msgs.srv import NavigateToPose
# Option 1: Using tf2_ros (if applicable)
from tf2_ros import TransformBroadcaster, TransformListener
# Option 2: Using a custom service (if available)
# from your_navigation_stack.srv import GetCustomInitialPose  # Replace with actual service name

class RelativeGoalPublisher(Node):

  def __init__(self):
    super().__init__('relative_goal_publisher')
    self.goal_pub = self.create_client(NavigateToPose, '/move_base')  # Service for sending navigation goals

    # Option 1: Using tf2_ros
    self.tf_buffer = TransformListener(self)
    self.tf_broadcaster = TransformBroadcaster(self)

    # Option 2: Using a custom service (if available)
    # self.get_pose_client = self.create_client(GetCustomInitialPose, '/your_custom_service_name')  # Replace with actual service name

    self.timer = self.create_timer(1.0, self.get_initial_pose_and_send_goal)  # Timer to trigger actions

    self.initial_pose_received = False  # Flag to indicate if initial pose is received
    self.initial_pose = None  # Placeholder for initial pose

    self.relative_x_offset = 1.0  # Desired X-axis offset (meters)

  def get_initial_pose_and_send_goal(self):
    if self.initial_pose_received:
      return  # Skip if initial pose is already received and sent

    # Try using tf2_ros to get the initial pose (if applicable)
    try:
      transform = self.tf_buffer.lookup_transform('map', 'base_link', rclpy.time.Time())
      self.initial_pose = transform.transform.translation
      self.initial_pose_received = True
      self.send_relative_goal()
      return  # Exit after successful retrieval using tf2_ros
    except (LookupError, rclpy.exceptions.ROSInterruptException) as e:
      self.get_logger().warn(f'Error getting initial pose using tf2_ros: {e}')

    # If tf2_ros fails, try using a custom service (if available)
    # Optionally uncomment and replace with your actual service call logic
    # get_pose_request = GetCustomInitialPose.Request()
    # future = self.get_pose_client.send_request(get_pose_request)
    # ... (handle future and extract initial pose if successful)

    self.initial_pose_received = False  # Reset flag on error

  def send_relative_goal(self):
    if not self.initial_pose_received:
      return  # Wait for initial pose before sending goal

    # Calculate the relative goal pose based on the initial pose
    goal_pose = PoseStamped()
    goal_pose.header.stamp.sec = 0  # Set timestamp to 0 seconds
    goal_pose.header.frame_id = self.initial_pose.frame_id  # Use same frame as initial pose
    goal_pose.pose.position.x = self.initial_pose.x + self.relative_x_offset
    goal_pose.pose.position.y = self.initial_pose.y  # No Y offset in this example
    goal_pose.pose.position.z = self.initial_pose.z  # No Z offset in this example
    goal_pose.pose.orientation = self.initial_pose.orientation  # Maintain the initial orientation

    # Send the navigation goal request using `/move_base`
    goal_request = NavigateToPose.Request()
    goal_request.pose = goal_pose
    future = self.goal_pub.send_request(goal_request)

    # Handle asynchronous response (optional)
    # This example logs a message when a response is received
    # You can modify this to implement logic based on the response
    def goal_response_callback(future):
      self.get_logger().info(f'Goal response received: {future.result()}')

    future.add_done_callback(goal_response_callback)

def main():
  rclpy.init()
  
