import rclpy
import cv2 as cv
import sys
import math
import numpy as np
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge

class ImagePublisher(Node):

    def __init__(self):
        super().__init__('image_publisher')
        self.publisher_ = self.create_publisher(Image, 'video_frames', 10)
        self.timer_period = 0.1  # seconds
        self.timer = self.create_timer(self.timer_period, self.timer_callback)

        # Handle camera connection based on serial or UVC
        try:
            # Attempt serial connection (replace with your specific code)
            # ...
        except Exception as e:
            print(f"Serial camera connection failed: {e}")
            # Fallback to UVC camera (if applicable)
            self.cap = cv.VideoCapture(0)  # Use index 0 for default camera

        self.br = CvBridge()

    def timer_callback(self):
        ret, img = self.cap.read()

        if ret:
            # Publish the image
            self.publisher_.publish(self.br.cv2_to_imgmsg(img))
            self.get_logger().info('Publishing video frame')

        cv.imshow("Object", img)
        if cv.waitKey(1) & 0xFF == ord('q'):
            self.destroy_node()
            rclpy.shutdown()

def main(args=None):
    rclpy.init(args=args)
    image_publisher = ImagePublisher()
    rclpy.spin(image_publisher)

if __name__ == '__main__':
    main()





#!/usr/bin/env python3
import rclpy
import cv2 as cv
import sys
import math 
import numpy as np
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
from ultralytics import YOLO
import pyrealsense2 as rs


class ImagePublisher(Node):
    def __init__(self):

        super().__init__('image_publisher')
        self.publisher_ = self.create_publisher(Image, 'video_frames', 10)
        timer_period = 0.1  # seconds
        
        self.timer = self.create_timer(timer_period, self.timer_callback)
            
        camera_index= 2 # if the CameraPI_ID is 1s 
        self.cap = cv.VideoCapture(camera_index)

        self.br = CvBridge()
        

    def timer_callback(self):
        
        self.cap.set(3, 640)
        self.cap.set(4, 480)

        success, img = self.cap.read()

        if success == True:
        # Publish the image.
        # The 'cv2_to_imgmsg' method converts an OpenCV
        # image to a ROS 2 image message
            self.publisher_.publish(self.br.cv2_to_imgmsg(img))
        self.get_logger().info('Publishing video frame')

       

        cv.imshow("object" , img)
        if cv.waitKey(1) & 0xFF == ord('q'):
            break
       
        cv.destroyAllWindows()

def main(args=None):
    rclpy.init(args=args)
    image_publisher = ImagePublisher()
    rclpy.spin(image_publisher)
    image_publisher.destroy_node()
    rclpy.shutdown()







import rclpy
from rclpy.node import Node
from std_msgs.msg import Int8

class StopSignalPublisher(Node):

  def __init__(self):
    super().__init__('stop_signal_publisher')
    self.pub = self.create_publisher(Int8, '/signal')  # Publisher for stop signal

  def send_stop_signal(self):
    msg = Int8()
    msg.data = 1  # Set the data to the stop signal value
    self.pub.publish(msg)
    self.get_logger().info('Sent stop signal.')

def main():
  rclpy.init()
  signal_publisher = StopSignalPublisher()
  # Send the stop signal here (e.g., user input, timer)
  signal_publisher.send_stop_signal()
  rclpy.shutdown()

if __name__ == '__main__':
  main()





import rclpy
from rclpy.node import Node
from your_service_package.srv import TriggerStop  # Replace with your service type (adapt message fields if needed)


class SignalListenerNode(Node):

  def __init__(self):
    super().__init__('signal_listener')
    self.srv_server = self.create_service(TriggerStop, '/trigger_stop', self.service_callback)

  def service_callback(self, request, response):
    if request.stop_signal == 1:  # Check for the stop signal value (adapt if message fields differ)
      self.get_logger().info('Received stop signal. Terminating launch.')
      # Use a mechanism to terminate the launch (replace with your preferred method)
      # Option 1: Using launch.shutdown (if launch API available)
      import launch
      launch.shutdown()

      # Option 2: Using a custom ROS action server (example)
      # action_client = self.create_client(CustomTerminateAction, '/terminate_launch')
      # ... (send termination request to action server)

      response.success = True  # Set service response (optional)
      return response
    else:
      self.get_logger().info('Received signal, but not the stop value. Ignoring.')
      response.success = False
      return response

def main():
  rclpy.init()
  signal_listener = SignalListenerNode()
  rclpy.spin(signal_listener)  # Keep the node running to listen for service calls
  rclpy.shutdown()

if __name__ == '__main__':
  main()

import os
from launch_ros.actions import Node
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():

  rosbot_description = get_package_share_directory('rosbot_description')
  config_dir = os.path.join(rosbot_description, 'config')
  params_file = os.path.join(config_dir, 'husarion_custom_param.yaml')
  rviz_config_dir = os.path.join(config_dir, 'navigation_rviz')

  # Define launch argument (optional, for potential future use with ROS message passing)
  stop_signal_arg = DeclareLaunchArgument(
      'stop_signal',
      default_value='1',  # Set default value to trigger stop on receiving "1"
      description='Signal value to stop the launch (optional)')

  # Include other launch descriptions for robot nodes (navigation, etc.)
  robot_nodes = IncludeLaunchDescription(
      PythonLaunchDescriptionSource([rosbot_description, '/launch/navigation_docker.launch.py']),
  )

  # Signal listener node
  signal_listener = Node(
      package='your_package_name',  # Replace with the package containing the signal listener node
      executable='signal_listener_node',  # Replace with the actual node name
      name='signal_listener')

  # Launch description
  return LaunchDescription([
      stop_signal_arg,  # Optional launch argument (uncomment if using message passing)
      robot_nodes,
      signal_listener,
  ])

import os
from launch_ros.actions import Node
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():

    rosbot_description = get_package_share_directory('rosbot_description')
    config_dir =os.path.join(rosbot_description , 'config')
    params_file = os.path.join(config_dir,'husarion_custom_param.yaml')
    rviz_config_dir=os.path.join(config_dir ,'navigation_rviz')
							

    return LaunchDescription([
        
       IncludeLaunchDescription(
           PythonLaunchDescriptionSource([rosbot_description, '/launch/navigation_docker.launch.py']),
 
       ),
       IncludeLaunchDescription(
           PythonLaunchDescriptionSource([rosbot_description, '/launch/rosbot_pro.launch.py']),
 
       ),
        
    # Node(
    #     package='rviz2',
    #     executable='rviz2',
    #     name='rviz2_node',
    #     arguments=['-d' ,rviz_config_dir],
    #     output='screen'
        
    # ),
	 Node(
        package='camera_package',
        executable='image_publisher',
        name='rimage_publisher_node',
        output='screen'
        
    ),	
    ])
