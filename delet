root@husarion:/# df -h
Filesystem      Size  Used Avail Use% Mounted on
overlay          29G   27G   58M 100% /
tmpfs            64M     0   64M   0% /dev
tmpfs           1.7G     0  1.7G   0% /sys/fs/cgroup
/dev/mmcblk0p2   29G   27G   58M 100% /etc/hosts
tmpfs           1.7G     0  1.7G   0% /dev/shm


docker pull osrf/ros:foxy-desktop



failed to register layer: Error processing tar file(exit status 1): write /opt/ros/foxy/lib/python3.8/site-packages/qt_gui_cpp/libqt_gui_cpp_sip.so: no space left on device















# Default to C99
if(NOT CMAKE_C_STANDARD)
  set(CMAKE_C_STANDARD 99)
endif()

# Default to C++14
if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 14)
endif()

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclpy REQUIRED)
find_package(gazebo_ros_pkgs REQUIRED)

find_package(rclcpp REQUIRED)
# find_package(rclcpp_lifecycle REQUIRED)
find_package(tf2_geometry_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(tf2_ros REQUIRED)
find_package(tf2 REQUIRED)

include_directories(
  include
)

#################
## Executables ##
#################

set(dependencies
  rclcpp
  tf2_geometry_msgs
  geometry_msgs
  tf2_ros
  tf2
)

add_executable(rosbot_tf src/rosbot_tf_node.cpp src/rosbot_tf.cpp)
target_link_libraries(rosbot_tf ${Boost_LIBRARIES})
ament_target_dependencies(rosbot_tf rclcpp geometry_msgs tf2 tf2_ros tf2_geometry_msgs)

#############
## Install ##
#############

install(DIRECTORY config launch models worlds urdf meshes rviz
  DESTINATION share/${PROJECT_NAME}
)

install(TARGETS rosbot_tf
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)

install(PROGRAMS 
  scripts/rosserial_node.py
  scripts/serialclient.py
  DESTINATION lib/${PROJECT_NAME}
)

install(DIRECTORY 
  scripts/rosserial
  DESTINATION lib/${PROJECT_NAME}
)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # uncomment the line when a copyright and license is not present in all source files
  #set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # uncomment the line when this package is not in a git repo
  #set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()


orange@nuc-ros:/app/augmented-robots/server/nux_ws$ colcon build --packages-select rosbot_description 
Starting >>> rosbot_description
--- stderr: rosbot_description                         
make: /home/orange/.local/lib/python3.8/site-packages/cmake/data/bin/cmake: No such file or directory
make: *** [Makefile:294: cmake_check_build_system] Error 127
---
Failed   <<< rosbot_description [0.17s, exited with code 2]

Summary: 0 packages finished [1.18s]
  1 package failed: rosbot_description
  1 package had stderr output: rosbot_description
orange@nuc-ros:/app/augmented-robots/server/nux_ws$ 


import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge

class ImageSubscriber(Node):

  def __init__(self):
    super().__init__('image_subscriber')
    self.sub = self.create_subscription(Image, 'video_frames', self.image_callback, 10)
    self.br = CvBridge()

  def image_callback(self, msg):
    # Convert ROS image message to OpenCV image
    cv_image = self.br.imgmsg_to_cv2(msg)

    # Display the image
    cv.imshow("Received Image", cv_image)
    cv.waitKey(1)

def main(args=None):
  rclpy.init(args=args)
  image_subscriber = ImageSubscriber()
  rclpy.spin(image_subscriber)
  rclpy.shutdown()

if __name__ == '__main__':
  main()





import rclpy
import cv2 as cv
import sys
import math
import numpy as np
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge

class ImagePublisher(Node):

    def __init__(self):
        super().__init__('image_publisher')
        self.publisher_ = self.create_publisher(Image, 'video_frames', 10)
        self.timer_period = 0.1  # seconds
        self.timer = self.create_timer(self.timer_period, self.timer_callback)

        # Handle camera connection based on serial or UVC
        try:
            # Attempt serial connection (replace with your specific code)
            # ...
        except Exception as e:
            print(f"Serial camera connection failed: {e}")
            # Fallback to UVC camera (if applicable)
            self.cap = cv.VideoCapture(0)  # Use index 0 for default camera

        self.br = CvBridge()

    def timer_callback(self):
        ret, img = self.cap.read()

        if ret:
            # Publish the image
            self.publisher_.publish(self.br.cv2_to_imgmsg(img))
            self.get_logger().info('Publishing video frame')

        cv.imshow("Object", img)
        if cv.waitKey(1) & 0xFF == ord('q'):
            self.destroy_node()
            rclpy.shutdown()

def main(args=None):
    rclpy.init(args=args)
    image_publisher = ImagePublisher()
    rclpy.spin(image_publisher)

if __name__ == '__main__':
    main()





#!/usr/bin/env python3
import rclpy
import cv2 as cv
import sys
import math 
import numpy as np
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
from ultralytics import YOLO
import pyrealsense2 as rs


class ImagePublisher(Node):
    def __init__(self):

        super().__init__('image_publisher')
        self.publisher_ = self.create_publisher(Image, 'video_frames', 10)
        timer_period = 0.1  # seconds
        
        self.timer = self.create_timer(timer_period, self.timer_callback)
            
        camera_index= 2 # if the CameraPI_ID is 1s 
        self.cap = cv.VideoCapture(camera_index)

        self.br = CvBridge()
        

    def timer_callback(self):
        
        self.cap.set(3, 640)
        self.cap.set(4, 480)

        success, img = self.cap.read()

        if success == True:
        # Publish the image.
        # The 'cv2_to_imgmsg' method converts an OpenCV
        # image to a ROS 2 image message
            self.publisher_.publish(self.br.cv2_to_imgmsg(img))
        self.get_logger().info('Publishing video frame')

       

        cv.imshow("object" , img)
        if cv.waitKey(1) & 0xFF == ord('q'):
            break
       
        cv.destroyAllWindows()

def main(args=None):
    rclpy.init(args=args)
    image_publisher = ImagePublisher()
    rclpy.spin(image_publisher)
    image_publisher.destroy_node()
    rclpy.shutdown()







import rclpy
from rclpy.node import Node
from std_msgs.msg import Int8

class StopSignalPublisher(Node):

  def __init__(self):
    super().__init__('stop_signal_publisher')
    self.pub = self.create_publisher(Int8, '/signal')  # Publisher for stop signal

  def send_stop_signal(self):
    msg = Int8()
    msg.data = 1  # Set the data to the stop signal value
    self.pub.publish(msg)
    self.get_logger().info('Sent stop signal.')

def main():
  rclpy.init()
  signal_publisher = StopSignalPublisher()
  # Send the stop signal here (e.g., user input, timer)
  signal_publisher.send_stop_signal()
  rclpy.shutdown()

if __name__ == '__main__':
  main()





import rclpy
from rclpy.node import Node
from your_service_package.srv import TriggerStop  # Replace with your service type (adapt message fields if needed)


class SignalListenerNode(Node):

  def __init__(self):
    super().__init__('signal_listener')
    self.srv_server = self.create_service(TriggerStop, '/trigger_stop', self.service_callback)

  def service_callback(self, request, response):
    if request.stop_signal == 1:  # Check for the stop signal value (adapt if message fields differ)
      self.get_logger().info('Received stop signal. Terminating launch.')
      # Use a mechanism to terminate the launch (replace with your preferred method)
      # Option 1: Using launch.shutdown (if launch API available)
      import launch
      launch.shutdown()

      # Option 2: Using a custom ROS action server (example)
      # action_client = self.create_client(CustomTerminateAction, '/terminate_launch')
      # ... (send termination request to action server)

      response.success = True  # Set service response (optional)
      return response
    else:
      self.get_logger().info('Received signal, but not the stop value. Ignoring.')
      response.success = False
      return response

def main():
  rclpy.init()
  signal_listener = SignalListenerNode()
  rclpy.spin(signal_listener)  # Keep the node running to listen for service calls
  rclpy.shutdown()

if __name__ == '__main__':
  main()

import os
from launch_ros.actions import Node
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():

  rosbot_description = get_package_share_directory('rosbot_description')
  config_dir = os.path.join(rosbot_description, 'config')
  params_file = os.path.join(config_dir, 'husarion_custom_param.yaml')
  rviz_config_dir = os.path.join(config_dir, 'navigation_rviz')

  # Define launch argument (optional, for potential future use with ROS message passing)
  stop_signal_arg = DeclareLaunchArgument(
      'stop_signal',
      default_value='1',  # Set default value to trigger stop on receiving "1"
      description='Signal value to stop the launch (optional)')

  # Include other launch descriptions for robot nodes (navigation, etc.)
  robot_nodes = IncludeLaunchDescription(
      PythonLaunchDescriptionSource([rosbot_description, '/launch/navigation_docker.launch.py']),
  )

  # Signal listener node
  signal_listener = Node(
      package='your_package_name',  # Replace with the package containing the signal listener node
      executable='signal_listener_node',  # Replace with the actual node name
      name='signal_listener')

  # Launch description
  return LaunchDescription([
      stop_signal_arg,  # Optional launch argument (uncomment if using message passing)
      robot_nodes,
      signal_listener,
  ])

import os
from launch_ros.actions import Node
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():

    rosbot_description = get_package_share_directory('rosbot_description')
    config_dir =os.path.join(rosbot_description , 'config')
    params_file = os.path.join(config_dir,'husarion_custom_param.yaml')
    rviz_config_dir=os.path.join(config_dir ,'navigation_rviz')
							

    return LaunchDescription([
        
       IncludeLaunchDescription(
           PythonLaunchDescriptionSource([rosbot_description, '/launch/navigation_docker.launch.py']),
 
       ),
       IncludeLaunchDescription(
           PythonLaunchDescriptionSource([rosbot_description, '/launch/rosbot_pro.launch.py']),
 
       ),
        
    # Node(
    #     package='rviz2',
    #     executable='rviz2',
    #     name='rviz2_node',
    #     arguments=['-d' ,rviz_config_dir],
    #     output='screen'
        
    # ),
	 Node(
        package='camera_package',
        executable='image_publisher',
        name='rimage_publisher_node',
        output='screen'
        
    ),	
    ])




import rclpy
from geometry_msgs.msg import Odometry
from tf2_ros.msg import TFMessage

class OdomTfSubscriber(rclpy.Node):

    def __init__(self):
        super().__init__('odom_tf_subscriber')

        self.odom_subscription = self.create_subscription(
            Odometry, '/odom', self.odom_callback, 10
        )
        self.tf_subscription = self.create_subscription(
            TFMessage, '/tf', self.tf_callback, 10
        )

    def odom_callback(self, msg: Odometry):
        """Callback for /odom topic"""
        print("Odom reçu :")
        print(f"  x: {msg.pose.pose.position.x}")
        print(f"  y: {msg.pose.pose.position.y}")
        print(f"  z: {msg.pose.pose.position.z}")
        print(f"  orientation (quaternion): {msg.pose.pose.orientation}")

    def tf_callback(self, msg: TFMessage):
        """Callback for /tf topic"""
        print("TF reçu :")
        for transform in msg.transforms:
            print(f"  transform de {transform.header.frame_id} à {transform.child_frame_id}")
            print(f"    translation: {transform.transform.translation}")
            print(f"    rotation (quaternion): {transform.transform.rotation}")


def main(args=None):
    rclpy.init(args=args)

    node = OdomTfSubscriber()

    rclpy.spin(node)

    rclpy.shutdown()

if __name__ == '__main__':
    main()

